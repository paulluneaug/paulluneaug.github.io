---
draft: false
title: "Fractals and Procedural Generation"
cover: /images/projects/covers/FractalsProceduralGeneration.jpg
alt: "Fractals and Procedural Generation cover"
description: " "
tags: ['Unity', 'C#', 'HLSL', 'Shaders', 'Compute shaders', 'Procedural Generation']
publishDate: 2023-08-10
highlight: true
---

### Overview

**Platform :** PC {{< br >}}
**Duration :** 7 months {{< br >}}
**Team size :** 1 {{< br >}}
**Role :** System & Tools Programmer, Tech Artist

## Project description

*Fractals and Procedural Generation* is a project I made first to learn to write my fist shaders in HLSL by implementing a Julia's fractal renderer. But I quickly became more and more interested in the subject so I stated to implement an infinite procedural world using Perlin noise and the marching cube algorithm

## Technical overview

### Languages and tools used

This project was made using Unity and used a lot of **HLSL** for both **compute shaders** and **fragment shaders** as well as **C#**.

During the project I also had the opportunity to use some more advanced C# and Unity features like **unmanaged memory**, **pointers** and Unity's **Jobs system**.

### Marching cube

For this part of the project, I implemented :

- A **3D perlin noise generator** in HLSL
- A **marching cube generator** capable of generating an infinite world and grouping cells into chunks with a mix of HLSL and C#

{{< figure
    src="images/chunk.png"
    alt="A screenshot of the mesh of a chunk"
    caption="A generated chunk"
    class="width-100"
    containerClass="width-60 center-img"
    >}}

The result kinda looked like an underwater cave system, so I modelled a simple submarine in Blender to make it look somewhat like a game.

{{< figure
    src="images/submarine.png"
    alt="A screenshot of the game with a submarine in a subarine cave like environment"
    class="width-100"
    containerClass="width-60 center-img"
    >}}

#### Optimizations

One thing I wanted to optimize while making this project were the meshes generated by the marching cube algorithm.
Indeed, when 2 neighbouring cells are generated, the vertices they're supposed to share are actually duplicated, one in each cell mesh.

{{< figure
    src="images/duplicate_vertices.svg"
    alt="Illustration of 2 cells, sharing duplicate vertices"
    class="width-100"
    containerClass="width-60 center-img"
    caption="Two neighbouring cells share vertices but they are duplicated, one in each cube"
    >}}

My goal was to remove these duplicate vertices when grouping the cells into chunks or even better, not creating them in the first place. {{< br >}}
To do so, we can simply not create vertices if they belong to the edges around the origin of the cell as they will be created by the neighbouring cells.

{{< figure
    src="images/vertices_optimization.svg"
    alt="Illustration of the way we can reduce the number of vertices by only creating some of them, arrond the origin of the cell"
    class="width-100"
    containerClass="width-60 center-img"
    caption="For a given cell, we only create the vertices arround the origin (the solid colored ones) : the rest will be taken care by the neighbouring cells"
    >}}


### Possible improvements

If I have time, I would like to go back to this project and improve it.

#### Algorithm

For instance, the algorithm that removes duplicate vertices and groups the cube meshes into chunks could be optimized and parallelized more efficiently.

#### Data structure

The data structure of the marching cube cells could also be shrunk to use less VRAM and reduce the time needed to retrieve informations from the GPU.

Currently, each cell is a struct able to hold 12 vertices (12 × 3 floats) and 4 triangles (4 × 3 ints) for a total size of (12 × 3 + 4 × 3) × 4 = 192 bytes. {{< br >}}
The cells are then merged into bigger chunk meshes grouping 16 cells in each dimension

But given that the the vertices are only stored in this cell if they are part of the edges arround the origin of the cube, we could in theory trim the cell struct to just 3 vertices and 4 triangles.
The  for the 16th slice in each dimention which cant point to the next slice because it is a different chunk

Fixing this is pretty easy, we could just increase the size of the chunks by 1 in each dimension, using the added cells to store the edge vertices.

The cells size would go from 192 bytes to 84 bytes. {{< br >}}
And the chunk size would go from 16³ × 192 = 786 KB to 17³ × 84 = 412 MB, nearly half the current size.

## Links

{{< button href="https://paulluneau.itch.io/fractals-and-procedural-generation" target="_blank">}}
{{< icon "itchio" >}} Itch.io
{{< /button >}}

{{< empty-p >}}

{{< itchio id="2476645" linkback="true" dark="true" >}}

{{< empty-p >}}

{{< button href="https://github.com/paulluneaug/Shaders_Fractal_Noise_and_ProceduralGeneration" target="_blank">}}
{{< icon "github" >}} GitHub Repository
{{< /button >}}

{{< empty-p >}}

{{< github repo="paulluneaug/Shaders_Fractal_Noise_and_ProceduralGeneration" showThumbnail=false >}}